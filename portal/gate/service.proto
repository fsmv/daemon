syntax = "proto3";
option go_package = "ask.systems/daemon/portal/gate";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

service Portal {
	rpc Register(RegisterRequest) returns (Lease) {}
	rpc Renew(Lease) returns (Lease) {}
	rpc Unregister(Lease) returns (Lease) {}

	// Returns the address that will be used to connect to your server if
	// registered. It is necessary to register the correct hostname in the TLS
	// certificate signed by portal.
	rpc MyHostname(google.protobuf.Empty) returns (Hostname) {}
}

message Hostname {
	string hostname = 1;
}

message RegisterRequest {
	// For HTTP: A url pattern that works with http.DefaultServMux. Ex: /images/
	// For TCP: ":tcp:port" for the port number portal should listen on. Only tcp
	// is accepted for now.
	//
	// HTTP patterns optionally accept a hostname (URL) constraint prefix. Or if
	// portal is configured to use the default hostname for no hostname patterns,
	// you can use * for the hostname to always match all URLs. For example:
	//
	//     ask.systems/images/
	//     */favicon.ico
	string pattern = 1; // TODO: maybe support multiple patterns for the same IP/port
	// Set for third party web interfaces (or TCP proxy backends) that can't
	// use an random lease port.
	// Must be outside the range of portal's automatic ports.
	uint32 fixed_port = 2;
	// If true, remove the pattern in the URL of HTTP requests we forward to the
	// backend to hide that it is behind a reverse proxy.
	//
	// Ignored for TCP proxies.
	bool strip_pattern = 3;

	// If set, the server will sign the certificate request with portal's
	// certificate as the root and accept connections to the signed cert. This way
	// network traffic behind the reverse proxy can be encrypted.
	bytes certificate_request = 4;

	// If true, the requests will only be forwarded to the backend if the request
	// has passed HTTP basic auth for portal's -admin_logins list.
	bool admin_only = 5;
}

message Lease {
	string pattern = 1;
	uint32 port = 2;
	google.protobuf.Timestamp timeout = 3;

	// If generate_certificate was set in the request, this is the signed x509
	// certificate to use for your server. It will be renewed with the lease.
	bytes Certificate = 4;
}

// vim: set noexpandtab:
